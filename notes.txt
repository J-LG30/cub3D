grid of 64x64 tiles

WASD MOVEMENT:

W AND S (up and down) are straightforward in their add and substracting of the x and y values.

That being said, because of the way we parse the map, the origin of our grid is at the top left corner.
This doesnt change the x axis, but the y axis becomes upside down, meaning that if our player moves up
it is technically travelling down the y axis, closer to the origin. To offset this, and the reason why
the calculations all look relatively normal, we invert the N and S direction vectors. N becomes (0, -1) and S (0, 1);
I personally think offsetting the y axis at this level makes the code easier to read and understand.

A and D (left and right) use a strafing mechanism. If you've played a Zelda game for example, imagine what happens when you lock
onto a target and move left and right. Link does this little hop but maintains locked in and keeps the same field of view instead of rotating
his body. In essence, his position changes but his direction stays the same. This is the same principle as in our game.
To achieve this effect, we want to move our player across a line that is perpendicular to the direction line. Sparing you
vector calculations (which I'm not even that confident with anyways), I'll give an example.

If our player is facing North with a direction vector of (0, -1) and we press the D key to strafe right, we want
our player to move across the x axis. This is the same as a 90 degree rotation.

Usually right means a clockwise rotation, and left a counter-clockwise, but due to our offsetting of the N and S
directions, the rotations are swapped. Therefore, to achieve a direction vector of (1, 0) to make our player
move right, we must swap the x and y values, and negate the x value.

If we want to move left, we swap the values and negate the y value. This explains why the calculations are mismatched
in the code (would be easier to show with pictures).

ROTATION LEFT AND RIGHT ARROWS:

Use the rotation matrix:

{cos(theta) -sin(theta)} {x1}
{sin(theta) cos(theta) } {y1}

Do matrix multiplication to give {x2, y2} which is the point rotated around the origin by theta degrees.
derivation explained at: https://articulatedrobotics.xyz/tutorials/coordinate-transforms/rotation-matrices-2d/

The rotation matrix applies to counter clockwise rotation, which in our case should be rotating left.
However, due to the offset of the directions, counter clockwise rotation really makes our player rotate right in-game.
Therefore to rotate right, we apply the matrix multiplication as is, and to rotate left we multiply it but negate all the angle values.


TO FIX:

when facing North, I think the walls are being drawn one "unit" too close to the player. as in when the player is facing south, when
its right at the border of the walls (the row or column right before the walls) the wall will basically take up the whole screen. 
but when the player is facing north the wall takes up the whole screen even when the player still has a row/column inbetween them and
the walls so its messing with the graphics and collisions. also happening when facing West. South and East are fine.









